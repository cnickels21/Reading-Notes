# Reading Journal 401-05

## Linked Lists

We all know what an array is and what we can use it for, and like big O, we've heard of linked lists and they both seem daunting at first, until you can really wrap your head around what you can can do with linked lists and how you can assess and analyze that with big O.  So first, let's break down big O.  It's not a part of any language, and it's not something you write into your program for some functionality.  Big O is a way to analyze the efficiency of the code you are writing.  Generally speaking you won't have to worry extensively about memory management too much, that's what .NET does for you!  However, understanding how memory management works, both with space and time...the universe's ultimate questions, at least for a starting point.

So big O is the assessment of how our code will act within space and time.  So to analyze your code you want to look at the worst case scenario.  How much memory will this action or variable hold within the stack or heap.  Memory for an array is O\(n\) because it will hold one bit for each item in the array.  So worst case scenario here is how many items are in the array, and the same is true for linked lists.  So best case scenario here is O\(1\).  There is only one bit of memory being used.  But now we want to access an item in our given list or array.  If we have an array, we have O\(1\) because we can call any specific index of the array.  With a linked list, it is O\(n\) because you have to sift through the entire list until you reach what you are looking for because you can only access the list through the *head* node, or the first value in the list.  Then, through a pointer, that head node can only access its direct neighbor.  Each node along the line then points to the *next* neighbor, and one by one, the linked list steps through until the end.  So for each item in the list you have to perform a process until you either find the value you are looking for, or reach the final node in the list, whose reference pointer returns null.

Now that we've broken down how a singly linked list operates when called upon, let's talk about doubly linked lists.  That's right! There are different types of linked lists.  On any given day, an array is an array is an array.I think we've all been caught in that loop at least a few times.
.
.
.
.
.
 Where was I? Oh yeah, there is only one real difference between a singly and doubly linked list; being that now each node in your list. also holds a pointer reference to the neighbor preceding it.  That's fun, we can take a step to the left, or a step to the right!  Don't forget big O though.  No that we have two different things that we can do with the same list we potentially created an O\(2n\), worst case scenario.  While one thing is true, go forward, but also, while this other thing is true, go backward.  Two times our object, two times the effort and space.  But, now that we understand the core concept of what a list is and how it performs in our code, let's get to practice!