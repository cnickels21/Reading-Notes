# Reading Journal 401-06

## OOP Principles

There are five standard OOP principles, which can be shortened into the acronym *SOLID*; single responsibility, open closed, Liskov substitution, interface segregation, and dependency inversion.  The overall concept here is that each class you create in your code should stand up to industry standards of efficiency and independence, as well as understandability, flexibility, and maintainability.  Single responsibility makes enough sense; there should only be one reason a class changes \(like with a pure function where you don't want the object to hold too much variety in responsibility\). Open\closed also speaks for itself, relatively; you should be able to extend a class's behavior without modifying it, meaning that a class can evolve but should still act exactly in it's singly desired fashion. Liskov substitution is the idea of inheritance when working with a derived class; again, there should be no modification, only evolution.  Interface segregation is the idea behind JS modules; no client of any variety should depend on methods it doesn't use \(separate your classes into individual and small pieces in your program\).  And finally, dependency inversion is how you work with the given data; object instances should function without having to redefine your reference types \(ie. your classes\).

That is a lot of information, and we will talk about it more in days and weeks to come, but implementing these core principles into data structures and, well, your code in general becomes much easier when you utilize TDD; test driven development.  By writing single purpose, stand alone unit tests to verify the functionality of each method you write inside your class, you are given the capability to truly analyze your code based on these principles.  You are able to assess your code and ask the questions, "Am I trying to do too much here?", "What exactly am I trying to accomplish here", or "How can I split up responsibility to make this method function more efficiently?".  Through TDD you not only get to verify that your code works, but you can break it down and truly analyze your code, ultimately giving you an even stronger understanding of the world of a programmer.  The more you write tests, the more you will naturally grow into an effective programmer who can utilize best industry practices and standards.  But remember, no matter how much you think you know, do more research, and always break down your problems into individual, manageable, and maintainable solutions, and you will have won half the battle of writing effective and efficient code.  Next is just more practice; deliberate practice!