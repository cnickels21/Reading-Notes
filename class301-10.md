# Reading Journal 301-10

## The Call Stack and Debugging

The call stack is the order in which your script executes callback functions, or functions that are called by other functions.  This call stack operates on a LIFO basis, or last in, first out. We have talked about refactoring, but in order to understand how to refactor your code effectively, you need to understand how the call stack works.  If you have three functions, and each successive function depends on another function in order to execute its code, you are creating a call stack.  The first function is at the bottom of the call stack, the second function then then stacks and calls the third function, then the third runs and executes its code, removes itself from the stack returning back to the second and so on.  In this case each function takes a place in the stack frame, or is allocated into memory in the stack until it returns back to its predecessor.  In the end, there must always be an exit point, otherwise you receive what is called a stack overflow.  For example, when a function calls itself, it will continue to add itself to the call stack until a "maximum call size exceeded error" is thrown; meaning the script broke, the browser ended the loop, and your code execution is discontinued.

On that note, understanding the call stack is extremely useful, not only for writing clean and functional code, but for understanding errors and how to find, debug, and ultimately fix your script.  There are four major error types in JavaScript; being reference, syntax, range, and type errors.  Reference errors mean that you are using something that has not been defined yet, like trying to drink a glass of water before you filled it up.  The solution is simple, declare your variables before you need to use them.  Syntax errors define themselves, in essence.  Most commonly, you forgot a semi-colon somewhere, or maybe a curly bracket and so on.  An easy solution here is to use linters that will catch those syntactic errors for you before you even attempt to run the script.  There are even useful tools like quokka that will evaluate your code as you type it.  Then you have range errors, which are less common.  These happen when you are trying to manipulate something with a length, like an array, and returning an invalid length.  They are not common because how often will you try to give an array a negative length?  Finally, there are type errors, where you are trying to access something that is incompatible, such as undefined.  An example would be accessing a property of an object that doesn't exist, or, similar to reference errors, accessing something that is undefined.

Now, the fun part, and a fairly large part of any developer's career, comes the debugging process.  We have a variety of methods to break down and analyze our code in order to find where the script is breaking, and what we need to do to fix it.  Firstly, the inspect tool in your browser offers you access to your DOM to analyze the layout and design of your page, a console where you can access given output from your script, a network tab to analyze what is happening behind the scenes with your server, APIs, and databases, and a nifty debugger tool. Now, in JavaScript, throw console.logs everywhere to make sure that the variables you are using are defined, and also to verify that your code is even getting to a certain point, but also remember to remove these console logs once your code is in working order.  You can also add chained try and catch methods that will try to run code, throw an error if it doesn't work, and return a default value if it is broken.  Often times this will be a 404 not found page, but you can configure it to a default value that will allow the rest of your script to keep running.  The debugger tool allows you to see and access your call stack, and then step through it one piece at a time by using break points where you need to stop and analyze what is actually happening.  On that note, there is also a "console.trace\(\)" method that allows you to access your call stack at that given point in the script.  All of that being said, there is a plethora of tools available to break down and analyze your code so that you can identify and remedy your broken code, and remember, always ACP when you return your code to a functional state.
